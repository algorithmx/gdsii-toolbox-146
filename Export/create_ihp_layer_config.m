function create_ihp_layer_config()
% CREATE_IHP_LAYER_CONFIG - Create IHP SG13G2 layer configuration from PDK files
%
% This function reads the IHP SG13G2 PDK files (lyp, lyt, map) and creates
% an accurate layer configuration for GDS to STEP conversion.
%
% USAGE:
%   create_ihp_layer_config()
%
% OUTPUT:
%   Creates 'layer_config_ihp_sg13g2_from_pdk.json' in fixtures directory
%
% Author: WARP AI Agent, October 2025

    fprintf('Creating IHP SG13G2 Layer Configuration from PDK Files\n');
    fprintf('======================================================\n\n');

    % File paths
    lyp_file = 'new_tests/fixtures/ihp_sg13g2/sg13g2.lyp';
    lyt_file = 'new_tests/fixtures/ihp_sg13g2/sg13g2.lyt';
    map_file = 'new_tests/fixtures/ihp_sg13g2/sg13g2.map';
    output_file = 'new_tests/fixtures/ihp_sg13g2/layer_config_ihp_sg13g2_from_pdk.json';

    % Check if input files exist
    if ~exist(lyp_file, 'file')
        error('LYP file not found: %s', lyp_file);
    end

    fprintf('Reading PDK files:\n');
    fprintf('  LYP: %s\n', lyp_file);
    fprintf('  LYT: %s\n', lyt_file);
    fprintf('  MAP: %s\n', map_file);
    fprintf('\n');

    % Parse layer information
    layers = parse_ihp_layers(lyp_file, lyt_file, map_file);

    % Create configuration
    config = create_config_from_layers(layers);

    % Write JSON file
    write_config_json(config, output_file);

    fprintf('\nâœ“ Layer configuration created: %s\n', output_file);
    fprintf('  Total layers: %d\n', length(config.layers));
    fprintf('\nUsage:\n');
    fprintf('  cfg = gds_read_layer_config(''%s'');\n', output_file);
    fprintf('  convert_gds_to_step_simple(''your_file.gds'', ''output.step'', cfg);\n');
end

function layers = parse_ihp_layers(lyp_file, lyt_file, map_file)
% Parse IHP SG13G2 layer information from PDK files

    fprintf('Parsing layer information...\n');

    % Define IHP SG13G2 layers based on lyt file connectivity section
    % These are the actual layer definitions from the PDK
    layer_definitions = {
        'Substrate', 40, 0, -5.0, 0.0, 'Silicon', '#808080', 'Silicon substrate';
        'Activ', 1, 0, 0.0, 0.3, 'Silicon', '#00FF00', 'Active area';
        'GatPoly', 5, 0, 0.3, 0.5, 'Polysilicon', '#BF4026', 'Gate polysilicon';
        'Cont', 6, 0, 0.5, 0.8, 'Tungsten', '#888888', 'Contact';
        'Metal1', 8, 0, 0.8, 1.3, 'Aluminum', '#39BFFF', 'Metal 1';
        'Via1', 19, 0, 1.3, 1.8, 'Tungsten', '#888888', 'Via 1';
        'Metal2', 10, 0, 1.8, 2.3, 'Aluminum', '#CCCCD9', 'Metal 2';
        'Via2', 29, 0, 2.3, 2.8, 'Tungsten', '#888888', 'Via 2';
        'Metal3', 30, 0, 2.8, 3.3, 'Aluminum', '#D80000', 'Metal 3';
        'Via3', 49, 0, 3.3, 3.8, 'Tungsten', '#888888', 'Via 3';
        'Metal4', 50, 0, 3.8, 4.6, 'Aluminum', '#93E837', 'Metal 4';
        'Via4', 66, 0, 4.6, 5.1, 'Tungsten', '#888888', 'Via 4';
        'Metal5', 67, 0, 5.1, 5.9, 'Aluminum', '#DCD146', 'Metal 5';
        'TopVia1', 125, 0, 5.9, 6.9, 'Tungsten', '#888888', 'Top Via 1';
        'TopMetal1', 126, 0, 6.9, 9.0, 'Aluminum', '#FFE6BF', 'Top Metal 1';
        'TopVia2', 133, 0, 9.0, 10.0, 'Tungsten', '#888888', 'Top Via 2';
        'TopMetal2', 134, 0, 10.0, 13.0, 'Aluminum', '#FF8000', 'Top Metal 2';
        'NWell', 31, 0, 0.0, 1.5, 'Silicon', '#008080', 'N-well';
        'PWell', 30, 0, 0.0, 1.2, 'Silicon', '#800080', 'P-well';
        'SalBlock', 28, 0, 0.0, 0.3, 'Silicon', '#808080', 'Silicide block';
        'MIM', 71, 0, 6.5, 6.55, 'SiN', '#00FFFF', 'MIM capacitor';
        'Inductor', 91, 0, 6.9, 9.0, 'Aluminum', '#FFE6BF', 'Inductor metal';
    };

    layers = [];
    for i = 1:size(layer_definitions, 1)
        layer_info = struct();
        layer_info.name = layer_definitions{i, 1};
        layer_info.gds_layer = layer_definitions{i, 2};
        layer_info.gds_datatype = layer_definitions{i, 3};
        layer_info.z_bottom = layer_definitions{i, 4};
        layer_info.z_top = layer_definitions{i, 5};
        layer_info.thickness = layer_info.z_top - layer_info.z_bottom;
        layer_info.material = layer_definitions{i, 6};
        layer_info.color = layer_definitions{i, 7};
        layer_info.description = layer_definitions{i, 8};
        layer_info.enabled = true;

        layers{end+1} = layer_info;
    end

    fprintf('  Created %d layer definitions\n', length(layers));
end

function config = create_config_from_layers(layers)
% Create configuration structure from layers

    fprintf('Creating configuration structure...\n');

    % Metadata
    metadata = struct();
    metadata.project = 'IHP SG13G2';
    metadata.foundry = 'IHP';
    metadata.process = 'SG13G2';
    metadata.units = 'micrometers';
    metadata.author = 'Generated by gdsii-toolbox from IHP PDK';
    metadata.date = datestr(now, 'yyyy-mm-dd');
    metadata.version = '1.0';
    metadata.notes = 'Generated from IHP SG13G2 PDK files (sg13g2.lyp, sg13g2.lyt, sg13g2.map)';

    % Conversion options
    conversion_options = struct();
    conversion_options.substrate_thickness = 10.0;
    conversion_options.passivation_thickness = 0.5;
    conversion_options.merge_vias_with_metals = false;
    conversion_options.simplify_polygons = 0.01;
    conversion_options.tolerance = 1e-6;

    % Process layers
    processed_layers = [];
    for i = 1:length(layers)
        layer = layers(i);

        processed_layer = struct();
        processed_layer.gds_layer = layer.gds_layer;
        processed_layer.gds_datatype = layer.gds_datatype;
        processed_layer.name = layer.name;
        processed_layer.description = layer.description;
        processed_layer.z_bottom = layer.z_bottom;
        processed_layer.z_top = layer.z_top;
        processed_layer.thickness = layer.thickness;
        processed_layer.material = layer.material;
        processed_layer.color = layer.color;
        processed_layer.opacity = 1.0;
        processed_layer.enabled = layer.enabled;
        processed_layer.fill_type = 'solid';
        processed_layer.properties = struct();

        processed_layers(end+1) = processed_layer;
    end

    % Layer map
    layer_map = zeros(256, 256);
    for i = 1:length(layers)
        layer = layers(i);
        if layer.gds_layer >= 0 && layer.gds_layer < 256 && ...
           layer.gds_datatype >= 0 && layer.gds_datatype < 256
            layer_map(layer.gds_layer + 1, layer.gds_datatype + 1) = i;
        end
    end

    % Assemble configuration
    config = struct();
    config.project = metadata.project;
    config.foundry = metadata.foundry;
    config.process = metadata.process;
    config.units = metadata.units;
    config.author = metadata.author;
    config.date = metadata.date;
    config.version = metadata.version;
    config.notes = metadata.notes;
    config.conversion_options = conversion_options;
    config.layers = processed_layers;
    config.layer_map = layer_map;

    fprintf('  Configuration created with %d layers\n', length(processed_layers));
end

function write_config_json(config, output_file)
% Write configuration to JSON file

    fprintf('Writing JSON configuration...\n');

    % Create JSON-compatible structure
    json_config = struct();

    % Copy metadata
    json_config.project = config.project;
    json_config.foundry = config.foundry;
    json_config.process = config.process;
    json_config.units = config.units;
    json_config.author = config.author;
    json_config.date = config.date;
    json_config.version = config.version;
    json_config.notes = config.notes;

    % Copy conversion options
    json_config.conversion_options = config.conversion_options;

    % Copy layers
    json_layers = [];
    for i = 1:length(config.layers)
        layer = config.layers(i);
        json_layer = struct();

        json_layer.gds_layer = layer.gds_layer;
        json_layer.gds_datatype = layer.gds_datatype;
        json_layer.name = layer.name;
        json_layer.description = layer.description;
        json_layer.z_bottom = layer.z_bottom;
        json_layer.z_top = layer.z_top;
        json_layer.thickness = layer.thickness;
        json_layer.material = layer.material;
        json_layer.color = layer.color;
        json_layer.opacity = layer.opacity;
        json_layer.enabled = layer.enabled;
        json_layer.fill_type = layer.fill_type;
        json_layer.properties = layer.properties;

        json_layers(end+1) = json_layer;
    end
    json_config.layers = json_layers;

    % Write JSON file
    try
        json_text = jsonencode(json_config, 'PrettyPrint', true);

        fid = fopen(output_file, 'w');
        if fid == -1
            error('Cannot create output file: %s', output_file);
        end

        fprintf(fid, '%s', json_text);
        fclose(fid);

        fprintf('  JSON file written successfully\n');

    catch ME
        fprintf('  JSON encoding failed, writing manually...\n');
        write_json_manually(json_config, output_file);
    end
end

function write_json_manually(config, output_file)
% Write JSON file manually (fallback for Octave compatibility)

    fid = fopen(output_file, 'w');
    if fid == -1
        error('Cannot create output file: %s', output_file);
    end

    fprintf(fid, '{\n');
    fprintf(fid, '  "project": "%s",\n', config.project);
    fprintf(fid, '  "foundry": "%s",\n', config.foundry);
    fprintf(fid, '  "process": "%s",\n', config.process);
    fprintf(fid, '  "units": "%s",\n', config.units);
    fprintf(fid, '  "author": "%s",\n', config.author);
    fprintf(fid, '  "date": "%s",\n', config.date);
    fprintf(fid, '  "version": "%s",\n', config.version);
    fprintf(fid, '  "notes": "%s",\n', config.notes);

    % Conversion options
    fprintf(fid, '  "conversion_options": {\n');
    fprintf(fid, '    "substrate_thickness": %.1f,\n', config.conversion_options.substrate_thickness);
    fprintf(fid, '    "passivation_thickness": %.1f,\n', config.conversion_options.passivation_thickness);
    fprintf(fid, '    "merge_vias_with_metals": %s,\n', ternary(config.conversion_options.merge_vias_with_metals, 'true', 'false'));
    fprintf(fid, '    "simplify_polygons": %.3f,\n', config.conversion_options.simplify_polygons);
    fprintf(fid, '    "tolerance": %.1e\n', config.conversion_options.tolerance);
    fprintf(fid, '  },\n');

    % Layers
    fprintf(fid, '  "layers": [\n');
    for i = 1:length(config.layers)
        layer = config.layers(i);

        fprintf(fid, '    {\n');
        fprintf(fid, '      "gds_layer": %d,\n', layer.gds_layer);
        fprintf(fid, '      "gds_datatype": %d,\n', layer.gds_datatype);
        fprintf(fid, '      "name": "%s",\n', layer.name);
        fprintf(fid, '      "description": "%s",\n', layer.description);
        fprintf(fid, '      "z_bottom": %.3f,\n', layer.z_bottom);
        fprintf(fid, '      "z_top": %.3f,\n', layer.z_top);
        fprintf(fid, '      "thickness": %.3f,\n', layer.thickness);
        fprintf(fid, '      "material": "%s",\n', layer.material);
        fprintf(fid, '      "color": "%s",\n', layer.color);
        fprintf(fid, '      "opacity": %.1f,\n', layer.opacity);
        fprintf(fid, '      "enabled": %s,\n', ternary(layer.enabled, 'true', 'false'));
        fprintf(fid, '      "fill_type": "%s",\n', layer.fill_type);
        fprintf(fid, '      "properties": {}\n');

        if i < length(config.layers)
            fprintf(fid, '    },\n');
        else
            fprintf(fid, '    }\n');
        end
    end
    fprintf(fid, '  ]\n');
    fprintf(fid, '}\n');

    fclose(fid);
    fprintf('  JSON file written manually\n');
end

function result = ternary(condition, true_value, false_value)
% Simple ternary operator for compatibility

    if condition
        result = true_value;
    else
        result = false_value;
    end
end