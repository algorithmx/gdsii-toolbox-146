import './style.css'

// Import the enhanced GDSII types and utilities
import {
  GDSLibrary,
  GDSElement,
  GDSPoint,
  GDSBBox,
  DEFAULT_LAYER_COLORS
} from './gdsii-types';

import {
  isValidBBox
} from './gdsii-utils';

import {
  parseGDSII,
  loadWASMModule,
  validateWASMModule,
  loadConfig,
  autoLoadGDSFile
} from './wasm-interface';

import {
  calculateLibraryBBox
} from './hierarchy-resolver';

// Import new rendering system
import {
  RendererFactory,
  type IRenderer,
  type RenderStatistics
} from './renderer';

import type { Viewport } from './scene';

class GDSViewer {
  private canvas: HTMLCanvasElement;
  private fileInput: HTMLInputElement;
  private loadButton: HTMLButtonElement;
  private fileInfo: HTMLParagraphElement;
  private layerList: HTMLDivElement;
  private zoomInButton: HTMLButtonElement;
  private zoomOutButton: HTMLButtonElement;
  private resetViewButton: HTMLButtonElement;
  private infoPanel: HTMLDivElement;

  // New rendering system
  private renderer: IRenderer | null = null;
  private currentLibrary: GDSLibrary | null = null;
  private libraryBBox: GDSBBox | null = null;

  // Viewport state (used by new renderer)
  private viewport: Viewport = {
    center: { x: 0, y: 0 },
    width: 0,
    height: 0,
    zoom: 1
  };

  // Interaction state
  private isDragging: boolean = false;
  private dragStart: GDSPoint = { x: 0, y: 0 };
  private lastViewportCenter: GDSPoint = { x: 0, y: 0 };

  // WASM module state
  private wasmLoaded: boolean = false;

  // Performance monitoring
  private renderAnimationFrame: number | null = null;

  constructor() {
    this.canvas = document.getElementById('gdsCanvas') as HTMLCanvasElement;
    this.fileInput = document.getElementById('fileInput') as HTMLInputElement;
    this.loadButton = document.getElementById('loadButton') as HTMLButtonElement;
    this.fileInfo = document.getElementById('fileInfo') as HTMLParagraphElement;
    this.layerList = document.getElementById('layerList') as HTMLDivElement;
    this.zoomInButton = document.getElementById('zoomIn') as HTMLButtonElement;
    this.zoomOutButton = document.getElementById('zoomOut') as HTMLButtonElement;
    this.resetViewButton = document.getElementById('resetView') as HTMLButtonElement;
    this.infoPanel = document.getElementById('infoPanel') as HTMLDivElement;

    this.initializeRenderer();
    this.initializeWASM();
    this.setupEventListeners();
    this.resizeCanvas();
  }

  /**
   * Initialize the rendering system
   */
  private async initializeRenderer(): Promise<void> {
    try {
      console.log('🎨 Initializing renderer...');
      
      this.renderer = await RendererFactory.create(this.canvas, {
        backend: 'auto',
        debug: true,  // Enable debug mode to see culling statistics
        preferWebGL: false  // Start with Canvas2D for Phase 1
      });

      console.log('✓ Renderer initialized');
      console.log('Backend info:', RendererFactory.getBackendInfo());
      
      // Draw placeholder
      this.drawPlaceholder();
    } catch (error) {
      console.error('Failed to initialize renderer:', error);
      throw error;
    }
  }

  /**
   * Initialize the WASM module
   */
  private async initializeWASM(): Promise<void> {
    try {
      await loadWASMModule();
      this.wasmLoaded = true;
      console.log('GDS parser WASM module loaded successfully');

      // Initialize auto-load functionality
      await this.initializeAutoLoad();
    } catch (error) {
      console.error('Failed to load WASM module:', error);
      this.showMessage('Failed to load GDS parser. Some features may not be available.');
    }
  }

  /**
   * Initialize auto-load functionality based on configuration
   */
  private async initializeAutoLoad(): Promise<void> {
    try {
      console.log('🔄 Initializing auto-load functionality...');

      // Load configuration
      const config = await loadConfig();
      console.log('✓ Configuration loaded:', config);

      // Attempt auto-load if enabled
      const library = await autoLoadGDSFile(config);

      if (library) {
        console.log('✓ Auto-load successful!');
        this.currentLibrary = library;

        // Process the parsed library
        await this.processLibrary();
        this.updateFileInfo('auto-loaded.gds');
        this.updateLayerList();
        this.resetView();

        console.log('✓ Auto-loaded GDSII file processed and rendered');
      } else {
        console.log('ℹ️ Auto-load disabled or failed - showing placeholder');
      }
    } catch (error) {
      console.error('❌ Auto-load initialization failed:', error);
      this.showMessage(`Auto-load failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private setupEventListeners() {
    this.loadButton.addEventListener('click', () => this.loadFile());
    this.fileInput.addEventListener('change', () => this.processFile());

    this.zoomInButton.addEventListener('click', () => this.zoom(1.2));
    this.zoomOutButton.addEventListener('click', () => this.zoom(0.8));
    this.resetViewButton.addEventListener('click', () => this.resetView());

    this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
    this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
    this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

    window.addEventListener('resize', () => this.resizeCanvas());
  }

  private async loadFile() {
    this.fileInput.click();
  }

  private async processFile() {
    const file = this.fileInput.files?.[0];
    if (!file) {
      this.showMessage('Please select a GDSII file');
      return;
    }

    if (!file.name.match(/\.(gds|gdsii|gds2)$/i)) {
      this.showMessage('Please select a valid GDSII file (.gds, .gdsii, .gds2)');
      return;
    }

    this.showMessage(`Loading ${file.name}...`);

    try {
      const arrayBuffer = await file.arrayBuffer();
      const data = new Uint8Array(arrayBuffer);

      // Parse the GDSII file using WASM or fallback
      if (this.wasmLoaded && validateWASMModule()) {
        this.currentLibrary = await parseGDSII(data);
      } else {
        // Fallback to placeholder data if WASM is not available
        this.currentLibrary = await this.parseGDSIIPlaceholder(data);
      }

      // Process the parsed library
      await this.processLibrary();
      this.updateFileInfo(file.name);
      this.updateLayerList();
      this.resetView();

    } catch (error) {
      console.error('Error loading GDSII file:', error);
      this.showMessage(`Error loading file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Placeholder parser for when WASM is not available
   */
  private async parseGDSIIPlaceholder(data: Uint8Array): Promise<GDSLibrary> {
    console.log('Using placeholder GDSII parser - received', data.length, 'bytes');

    await new Promise(resolve => setTimeout(resolve, 500));

    return {
      name: 'Demo Library (Placeholder)',
      units: {
        userUnitsPerDatabaseUnit: 0.001,
        metersPerDatabaseUnit: 1e-9
      },
      structures: [
        {
          name: 'TOP_CELL',
          elements: [
            {
              type: 'boundary',
              layer: 1,
              dataType: 0,
              polygons: [
                [
                  { x: -100, y: -100 },
                  { x: 100, y: -100 },
                  { x: 100, y: 100 },
                  { x: -100, y: 100 }
                ]
              ]
            },
            {
              type: 'boundary',
              layer: 2,
              dataType: 0,
              polygons: [
                [
                  { x: -50, y: -50 },
                  { x: 50, y: -50 },
                  { x: 50, y: 50 },
                  { x: -50, y: 50 }
                ]
              ]
            },
            {
              type: 'path',
              layer: 3,
              dataType: 0,
              pathType: 0,
              width: 0.1,
              paths: [
                [
                  { x: -150, y: 0 },
                  { x: 150, y: 0 }
                ]
              ]
            }
          ],
          references: []
        }
      ]
    };
  }

  /**
   * Process the parsed library to prepare for rendering
   */
  private async processLibrary(): Promise<void> {
    if (!this.currentLibrary) return;

    try {
      // Flatten structures according to render options
      this.flattenedStructures.clear();
      for (const structure of this.currentLibrary.structures) {
        const flattened = flattenStructure(this.currentLibrary, structure, this.renderOptions);
        this.flattenedStructures.set(structure.name, flattened);
      }

      // Extract layers
      this.layers = extractLayersFromLibrary(this.currentLibrary, this.renderOptions);

      // Calculate library bounding box
      this.libraryBBox = calculateLibraryBBox(this.currentLibrary);

      console.log(`Processed ${this.currentLibrary.structures.length} structures`);
      console.log(`Found ${this.layers.size} unique layers`);
      console.log(`Library bounds:`, this.libraryBBox);

    } catch (error) {
      console.error('Error processing library:', error);
      throw error;
    }
  }

  private updateFileInfo(fileName: string) {
    if (!this.currentLibrary) return;

    const totalElements = this.currentLibrary.structures
      .reduce((sum, struct) => sum + struct.elements.length, 0);

    this.fileInfo.innerHTML = `
      <strong>File:</strong> ${fileName}<br>
      <strong>Library:</strong> ${this.currentLibrary.name}<br>
      <strong>Structures:</strong> ${this.currentLibrary.structures.length}<br>
      <strong>Total Elements:</strong> ${totalElements}
    `;
  }

  private updateLayerList() {
    if (!this.currentLibrary || this.layers.size === 0) return;

    this.layerList.innerHTML = '';

    // Sort layers by number for consistent display
    const sortedLayers = Array.from(this.layers.entries())
      .sort(([keyA, layerA], [keyB, layerB]) => {
        // Sort by layer number, then by data type
        if (layerA.number !== layerB.number) {
          return layerA.number - layerB.number;
        }
        return layerA.dataType - layerB.dataType;
      });

    sortedLayers.forEach(([layerKey, layer]) => {
      // Assign color if not already set
      if (!layer.color) {
        layer.color = this.getLayerColor(layer.number);
      }

      const layerItem = document.createElement('div');
      layerItem.className = 'layer-item';
      layerItem.innerHTML = `
        <div class="layer-color" style="background-color: ${layer.color}"></div>
        <input type="checkbox" id="layer-${layerKey}" checked>
        <label for="layer-${layerKey}">
          Layer ${layer.number} (DT ${layer.dataType})
          ${layer.name ? `- ${layer.name}` : ''}
        </label>
      `;

      const checkbox = layerItem.querySelector(`#layer-${layerKey}`) as HTMLInputElement;
      checkbox.addEventListener('change', () => {
        layer.visible = checkbox.checked;
        this.render();
      });

      this.layerList.appendChild(layerItem);
    });
  }

  private getLayerColor(layerNumber: number): string {
    return DEFAULT_LAYER_COLORS[layerNumber % DEFAULT_LAYER_COLORS.length];
  }

  private resizeCanvas() {
    const wrapper = this.canvas.parentElement as HTMLElement;
    if (wrapper) {
      this.canvas.width = wrapper.clientWidth;
      this.canvas.height = wrapper.clientHeight;
      this.render();
    }
  }

  
  private drawPlaceholder() {
    this.ctx.fillStyle = '#f0f0f0';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    this.ctx.fillStyle = '#999';
    this.ctx.font = '16px system-ui';
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';
    this.ctx.fillText('Load a GDSII file to visualize', this.canvas.width / 2, this.canvas.height / 2);
  }

  private render() {
    if (!this.currentLibrary || this.flattenedStructures.size === 0) {
      this.drawPlaceholder();
      return;
    }

    // Clear canvas
    this.ctx.fillStyle = '#ffffff';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Set up coordinate system
    this.ctx.save();
    this.ctx.translate(this.canvas.width / 2 + this.offsetX, this.canvas.height / 2 + this.offsetY);
    this.ctx.scale(this.scale, -this.scale);

    // Render all structures
    for (const [structureName, elements] of this.flattenedStructures) {
      for (const element of elements) {
        this.drawElement(element);
      }
    }

    this.ctx.restore();
  }

  private drawElement(element: GDSElement): void {
    // Skip reference elements as they should be resolved during flattening
    if (element.type === 'sref' || element.type === 'aref') {
      return;
    }

    // Check if element's layer is visible
    const layerKey = `${element.layer}_${element.dataType}`;
    const layer = this.layers.get(layerKey);
    if (!layer || !layer.visible) {
      return;
    }

    const color = layer.color;
    this.ctx.strokeStyle = color;
    this.ctx.fillStyle = color;
    this.ctx.lineWidth = Math.max(1, 1 / this.scale);

    // Apply rendering options
    const globalAlpha = this.renderOptions.showFill ? 0.3 : 0;
    const strokeEnabled = this.renderOptions.showStroke;

    switch (element.type) {
      case 'boundary':
        this.drawBoundaryElement(element as GDSBoundaryElement, globalAlpha, strokeEnabled);
        break;

      case 'path':
        this.drawPathElement(element as GDSPathElement, strokeEnabled);
        break;

      case 'box':
        this.drawBoxElement(element, globalAlpha, strokeEnabled);
        break;

      case 'node':
        this.drawNodeElement(element);
        break;

      case 'text':
        if (this.renderOptions.showText) {
          this.drawTextElement(element as GDSTextElement);
        }
        break;
    }
  }

  private drawBoundaryElement(element: GDSBoundaryElement, fillAlpha: number, strokeEnabled: boolean): void {
    this.ctx.globalAlpha = fillAlpha;

    for (const polygon of element.polygons) {
      if (polygon.length < 3) continue;

      this.ctx.beginPath();
      this.ctx.moveTo(polygon[0].x, polygon[0].y);
      for (let i = 1; i < polygon.length; i++) {
        this.ctx.lineTo(polygon[i].x, polygon[i].y);
      }
      this.ctx.closePath();

      // Fill
      if (fillAlpha > 0) {
        this.ctx.fill();
      }

      // Stroke
      if (strokeEnabled) {
        this.ctx.globalAlpha = 1.0;
        this.ctx.stroke();
        this.ctx.globalAlpha = fillAlpha;
      }
    }

    this.ctx.globalAlpha = 1.0;
  }

  private drawPathElement(element: GDSPathElement, strokeEnabled: boolean): void {
    if (!strokeEnabled) return;

    // Apply path width
    if (element.width > 0) {
      this.ctx.lineWidth = Math.max(1, (element.width * this.scale));
    }

    for (const path of element.paths) {
      if (path.length < 2) continue;

      this.ctx.beginPath();
      this.ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        this.ctx.lineTo(path[i].x, path[i].y);
      }

      this.ctx.stroke();
    }

    // Reset line width
    this.ctx.lineWidth = Math.max(1, 1 / this.scale);
  }

  private drawBoxElement(element: GDSElement, fillAlpha: number, strokeEnabled: boolean): void {
    // Box elements have 5 points forming a rectangle
    if (element.points.length < 5) return;

    this.ctx.globalAlpha = fillAlpha;

    this.ctx.beginPath();
    this.ctx.moveTo(element.points[0].x, element.points[0].y);
    for (let i = 1; i < element.points.length; i++) {
      this.ctx.lineTo(element.points[i].x, element.points[i].y);
    }
    this.ctx.closePath();

    // Fill
    if (fillAlpha > 0) {
      this.ctx.fill();
    }

    // Stroke
    if (strokeEnabled) {
      this.ctx.globalAlpha = 1.0;
      this.ctx.stroke();
    }

    this.ctx.globalAlpha = 1.0;
  }

  private drawNodeElement(element: GDSElement): void {
    // Draw nodes as small circles
    for (const point of element.points) {
      this.ctx.beginPath();
      this.ctx.arc(point.x, point.y, 2 / this.scale, 0, 2 * Math.PI);
      this.ctx.fill();
    }
  }

  private drawTextElement(element: GDSTextElement): void {
    this.ctx.save();

    // Flip coordinate system for text
    this.ctx.scale(1 / this.scale, -1 / this.scale);

    // Calculate font size
    const fontSize = Math.max(8, 12 / this.scale);
    this.ctx.font = `${fontSize}px system-ui`;

    // Set text alignment based on presentation properties
    if (element.presentation) {
      switch (element.presentation.horizontalJustification) {
        case 0: this.ctx.textAlign = 'left'; break;
        case 1: this.ctx.textAlign = 'center'; break;
        case 2: this.ctx.textAlign = 'right'; break;
        default: this.ctx.textAlign = 'left';
      }

      switch (element.presentation.verticalJustification) {
        case 0: this.ctx.textBaseline = 'top'; break;
        case 1: this.ctx.textBaseline = 'middle'; break;
        case 2: this.ctx.textBaseline = 'bottom'; break;
        default: this.ctx.textBaseline = 'bottom';
      }
    } else {
      this.ctx.textAlign = 'left';
      this.ctx.textBaseline = 'bottom';
    }

    // Apply text transformation if present
    if (element.transformation) {
      const angle = element.transformation.angle * Math.PI / 180;
      const mag = element.transformation.magnification;

      this.ctx.translate(element.position.x, -element.position.y);
      this.ctx.rotate(angle);
      this.ctx.scale(mag, mag);

      this.ctx.fillText(element.text, 0, 0);
    } else {
      this.ctx.fillText(element.text, element.position.x, -element.position.y);
    }

    this.ctx.restore();
  }

  private zoom(factor: number) {
    this.scale *= factor;
    this.scale = Math.max(0.01, Math.min(100, this.scale));
    this.render();
  }

  private resetView() {
    if (this.libraryBBox && isValidBBox(this.libraryBBox)) {
      // Calculate the scale to fit the entire design
      const designWidth = this.libraryBBox.maxX - this.libraryBBox.minX;
      const designHeight = this.libraryBBox.maxY - this.libraryBBox.minY;

      const padding = 20; // pixels
      const availableWidth = this.canvas.width - 2 * padding;
      const availableHeight = this.canvas.height - 2 * padding;

      const scaleX = availableWidth / designWidth;
      const scaleY = availableHeight / designHeight;

      // Use the smaller scale to fit everything
      this.scale = Math.min(scaleX, scaleY) * 0.9; // 0.9 for extra padding

      // Center the design
      const designCenterX = (this.libraryBBox.minX + this.libraryBBox.maxX) / 2;
      const designCenterY = (this.libraryBBox.minY + this.libraryBBox.maxY) / 2;

      this.offsetX = -designCenterX * this.scale;
      this.offsetY = -designCenterY * this.scale;
    } else {
      // Fallback to default view
      this.scale = 1;
      this.offsetX = 0;
      this.offsetY = 0;
    }

    this.render();
  }

  private handleMouseDown(e: MouseEvent) {
    this.isDragging = true;
    this.dragStart = { x: e.clientX, y: e.clientY };
    this.lastOffset = { x: this.offsetX, y: this.offsetY };
    this.canvas.style.cursor = 'grabbing';
  }

  private handleMouseMove(e: MouseEvent) {
    if (!this.isDragging) return;

    const dx = e.clientX - this.dragStart.x;
    const dy = e.clientY - this.dragStart.y;

    this.offsetX = this.lastOffset.x + dx;
    this.offsetY = this.lastOffset.y + dy;

    this.render();
  }

  private handleMouseUp() {
    this.isDragging = false;
    this.canvas.style.cursor = 'grab';
  }

  private handleWheel(e: WheelEvent) {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    this.zoom(factor);
  }

  private showMessage(message: string) {
    this.fileInfo.textContent = message;
  }

  // ============================================================================
  // MEMORY MANAGEMENT AND CLEANUP
  // ============================================================================

  /**
   * Cleanup method to free memory and reset state
   */
  public cleanup(): void {
    // Clear current library data
    this.currentLibrary = null;
    this.flattenedStructures.clear();
    this.layers.clear();
    this.libraryBBox = null;

    // Reset view state
    this.scale = 1;
    this.offsetX = 0;
    this.offsetY = 0;
    this.isDragging = false;
    this.dragStart = { x: 0, y: 0 };
    this.lastOffset = { x: 0, y: 0 };

    // Reset render options
    this.renderOptions = { ...DEFAULT_RENDER_OPTIONS };

    // Clear canvas
    if (this.ctx) {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    this.drawPlaceholder();
  }

  /**
   * Method to update render options
   */
  public updateRenderOptions(options: Partial<GDSRenderOptions>): void {
    this.renderOptions = { ...this.renderOptions, ...options };

    // Reprocess library if hierarchy flattening option changed
    if (this.currentLibrary &&
        (options.flattenHierarchy !== undefined ||
         options.maxDepth !== undefined)) {
      this.processLibrary().catch(error => {
        console.error('Error reprocessing library:', error);
      });
    }

    this.render();
  }

  /**
   * Method to get current statistics about the loaded GDSII file
   */
  public getLibraryStats(): {
    name: string;
    structureCount: number;
    layerCount: number;
    totalElements: number;
    flattenedElements: number;
    bounds?: GDSBBox;
    units: {
      userUnitsPerDatabaseUnit: number;
      metersPerDatabaseUnit: number;
    };
  } | null {
    if (!this.currentLibrary) {
      return null;
    }

    const totalElements = this.currentLibrary.structures
      .reduce((sum, struct) => sum + struct.elements.length, 0);

    const flattenedElements = Array.from(this.flattenedStructures.values())
      .reduce((sum, elements) => sum + elements.length, 0);

    return {
      name: this.currentLibrary.name,
      structureCount: this.currentLibrary.structures.length,
      layerCount: this.layers.size,
      totalElements,
      flattenedElements,
      bounds: this.libraryBBox || undefined,
      units: this.currentLibrary.units
    };
  }

  /**
   * Method to export current view as SVG (placeholder for future implementation)
   */
  public exportAsSVG(): string {
    // TODO: Implement SVG export
    return '<svg><!-- SVG export not yet implemented --></svg>';
  }

  /**
   * Method to get performance metrics
   */
  public getPerformanceMetrics(): {
    renderTime: number;
    memoryUsage?: number;
    wasmLoaded: boolean;
  } {
    const startTime = performance.now();
    this.render();
    const renderTime = performance.now() - startTime;

    return {
      renderTime,
      wasmLoaded: this.wasmLoaded,
      memoryUsage: (performance as any).memory?.usedJSHeapSize
    };
  }
}

const viewer = new GDSViewer();

// Make viewer available globally for debugging
declare global {
  interface Window {
    gdsViewer: GDSViewer;
  }
}

window.gdsViewer = viewer;